{"version":3,"file":"keychain.cjs.production.min.js","sources":["../src/nodes/app-node.ts","../src/nodes/apps-node.ts","../src/utils/index.ts","../src/nodes/identity-address-owner-node.ts","../src/encryption/encrypt.ts","../src/identity.ts","../src/utils/gaia.ts","../src/index.ts","../src/wallet.ts"],"sourcesContent":["import { BIP32Interface } from 'bip32'\nimport { getAddress } from '../utils'\n\nexport default class AppNode {\n  hdNode: BIP32Interface\n\n  appDomain: string\n\n  constructor(hdNode: BIP32Interface, appDomain: string) {\n    this.hdNode = hdNode\n    this.appDomain = appDomain\n  }\n\n  getAppPrivateKey() {\n    if (!this.hdNode.privateKey) {\n      throw new Error('Node does not have private key')\n    }\n    return this.hdNode.privateKey.toString('hex')\n  }\n\n  getAddress() {\n    return getAddress(this.hdNode)\n  }\n}\n","import { BIP32Interface } from 'bip32'\nimport { createHash } from 'crypto-browserify'\nimport { hashCode } from '../utils'\nimport AppNode from './app-node'\n\nexport default class AppsNode {\n  hdNode: BIP32Interface\n\n  salt: string\n\n  constructor(appsHdNode: BIP32Interface, salt: string) {\n    this.hdNode = appsHdNode\n    this.salt = salt\n  }\n\n  getNode() {\n    return this.hdNode\n  }\n\n  getAppNode(appDomain: string) {\n    const hash = createHash('sha256')\n      .update(`${appDomain}${this.salt}`)\n      .digest('hex')\n    const appIndex = hashCode(hash)\n    const appNode = this.hdNode.deriveHardened(appIndex)\n    return new AppNode(appNode, appDomain)\n  }\n\n  toBase58() {\n    return this.hdNode.toBase58()\n  }\n\n  getSalt() {\n    return this.salt\n  }\n}\n","import { BIP32Interface } from 'bip32'\nimport { address, networks, crypto } from 'bitcoinjs-lib'\nimport { createHash } from 'crypto-browserify'\nimport IdentityAddressOwnerNode from '../nodes/identity-address-owner-node'\n\nconst IDENTITY_KEYCHAIN = 888\nconst BLOCKSTACK_ON_BITCOIN = 0\nexport function getIdentityPrivateKeychain(masterKeychain: BIP32Interface) {\n  return masterKeychain\n    .deriveHardened(IDENTITY_KEYCHAIN)\n    .deriveHardened(BLOCKSTACK_ON_BITCOIN)\n}\n\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS'\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS'\n\nexport function getBitcoinPrivateKeychain(masterKeychain: BIP32Interface) {\n  const BIP_44_PURPOSE = 44\n  const BITCOIN_COIN_TYPE = 0\n  const ACCOUNT_INDEX = 0\n\n  return masterKeychain\n    .deriveHardened(BIP_44_PURPOSE)\n    .deriveHardened(BITCOIN_COIN_TYPE)\n    .deriveHardened(ACCOUNT_INDEX)\n}\n\nexport function getBitcoinAddressNode(\n  bitcoinKeychain: BIP32Interface,\n  addressIndex = 0,\n  chainType = EXTERNAL_ADDRESS\n) {\n  let chain = null\n\n  if (chainType === EXTERNAL_ADDRESS) {\n    chain = 0\n  } else if (chainType === CHANGE_ADDRESS) {\n    chain = 1\n  } else {\n    throw new Error('Invalid chain type')\n  }\n\n  return bitcoinKeychain.derive(chain).derive(addressIndex)\n}\n\nexport function getIdentityOwnerAddressNode(\n  identityPrivateKeychain: BIP32Interface,\n  identityIndex = 0\n) {\n  if (identityPrivateKeychain.isNeutered()) {\n    throw new Error('You need the private key to generate identity addresses')\n  }\n\n  const publicKeyHex = identityPrivateKeychain\n    .publicKey\n    .toString('hex')\n  const salt = createHash('sha256')\n    .update(publicKeyHex)\n    .digest('hex')\n\n  return new IdentityAddressOwnerNode(\n    identityPrivateKeychain.deriveHardened(identityIndex),\n    salt\n  )\n}\n\n// HDNode is no longer a part of bitcoinjs-lib\n// This function is taken from https://github.com/bitcoinjs/bitcoinjs-lib/pull/1073/files#diff-1f03b6ff764c499bfbdf841bf8fc113eR10\nexport function getAddress(node: BIP32Interface) {\n  return address.toBase58Check(\n    crypto.hash160(node.publicKey),\n    networks.bitcoin.pubKeyHash\n  )\n}\n\nexport function hashCode(string: string) {\n  let hash = 0\n  if (string.length === 0) return hash\n  for (let i = 0; i < string.length; i++) {\n    const character = string.charCodeAt(i)\n    hash = (hash << 5) - hash + character\n    hash &= hash\n  }\n  return hash & 0x7fffffff\n}\n\nexport interface IdentityKeyPair {\n  key: string\n  keyID: string\n  address: string\n  appsNodeKey: string\n  salt: string\n}\n\nexport function deriveIdentityKeyPair(identityOwnerAddressNode: IdentityAddressOwnerNode): IdentityKeyPair {\n  const address = identityOwnerAddressNode.getAddress()\n  const identityKey = identityOwnerAddressNode.getIdentityKey()\n  const identityKeyID = identityOwnerAddressNode.getIdentityKeyID()\n  const appsNode = identityOwnerAddressNode.getAppsNode()\n  const keyPair = {\n    key: identityKey,\n    keyID: identityKeyID,\n    address,\n    appsNodeKey: appsNode.toBase58(),\n    salt: appsNode.getSalt()\n  }\n  return keyPair\n}\n\nexport function getBlockchainIdentities(\n  masterKeychain: BIP32Interface,\n  identitiesToGenerate: number) {\n  const identityPrivateKeychainNode = getIdentityPrivateKeychain(\n    masterKeychain\n  )\n  const bitcoinPrivateKeychainNode = getBitcoinPrivateKeychain(\n    masterKeychain\n  )\n\n  const identityPublicKeychainNode = identityPrivateKeychainNode.neutered()\n  const identityPublicKeychain = identityPublicKeychainNode.toBase58()\n\n  const bitcoinPublicKeychainNode = bitcoinPrivateKeychainNode.neutered()\n  const bitcoinPublicKeychain = bitcoinPublicKeychainNode.toBase58()\n\n  const firstBitcoinAddress = getAddress(getBitcoinAddressNode(bitcoinPublicKeychainNode))\n\n  const identityAddresses = []\n  const identityKeypairs = []\n\n  // We pre-generate a number of identity addresses so that we\n  // don't have to prompt the user for the password on each new profile\n  for (\n    let addressIndex = 0;\n    addressIndex < identitiesToGenerate;\n    addressIndex++\n  ) {\n    const identityOwnerAddressNode = getIdentityOwnerAddressNode(\n      identityPrivateKeychainNode,\n      addressIndex\n    )\n    const identityKeyPair = deriveIdentityKeyPair(\n      identityOwnerAddressNode\n    )\n    identityKeypairs.push(identityKeyPair)\n    identityAddresses.push(\n      identityKeyPair.address\n    )\n  }\n\n  return {\n    identityPublicKeychain,\n    bitcoinPublicKeychain,\n    firstBitcoinAddress,\n    identityAddresses,\n    identityKeypairs\n  }\n}\n","import { BIP32Interface } from 'bip32'\nimport { getAddress } from '../utils'\nimport AppsNode from './apps-node'\n\nconst APPS_NODE_INDEX = 0\nconst SIGNING_NODE_INDEX = 1\nconst ENCRYPTION_NODE_INDEX = 2\n\nexport default class IdentityAddressOwnerNode {\n  hdNode: BIP32Interface\n\n  salt: string\n\n  constructor(ownerHdNode: BIP32Interface, salt: string) {\n    this.hdNode = ownerHdNode\n    this.salt = salt\n  }\n\n  getNode() {\n    return this.hdNode\n  }\n\n  getSalt() {\n    return this.salt\n  }\n\n  getIdentityKey() {\n    if (!this.hdNode.privateKey) {\n      throw new Error('Node does not have private key')\n    }\n    return this.hdNode.privateKey.toString('hex')\n  }\n\n  getIdentityKeyID() {\n    return this.hdNode.publicKey.toString('hex')\n  }\n\n  getAppsNode() {\n    return new AppsNode(this.hdNode.deriveHardened(APPS_NODE_INDEX), this.salt)\n  }\n\n  getAddress() {\n    // return this.hdNode.getAddress()\n    return getAddress(this.hdNode)\n  }\n\n  getEncryptionNode() {\n    return this.hdNode.deriveHardened(ENCRYPTION_NODE_INDEX)\n  }\n\n  getSigningNode() {\n    return this.hdNode.deriveHardened(SIGNING_NODE_INDEX)\n  }\n}\n","import { mnemonicToEntropy, validateMnemonic } from 'bip39'\nimport {\n  randomBytes,\n  pbkdf2Sync,\n  createCipheriv,\n  createHmac\n} from 'crypto-browserify'\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function normalizeMnemonic(mnemonic: string) {\n  // Note: Future-proofing with async wrappers around any synchronous cryptographic code.\n  return mnemonicToEntropy(mnemonic)\n}\n\nasync function encryptMnemonic(\n  mnemonic: string,\n  password: string\n): Promise<Buffer> {\n  // must be bip39 mnemonic\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error('Not a valid bip39 nmemonic')\n  }\n\n  // normalize plaintext to fixed length byte string\n  const normalizedMnemonic = await normalizeMnemonic(mnemonic)\n  const plaintextNormalized = Buffer.from(normalizedMnemonic, 'hex')\n\n  // AES-128-CBC with SHA256 HMAC\n  const salt = randomBytes(16)\n  const keysAndIV = pbkdf2Sync(password, salt, 100000, 48, 'sha512')\n  const encKey = keysAndIV.slice(0, 16)\n  const macKey = keysAndIV.slice(16, 32)\n  const iv = keysAndIV.slice(32, 48)\n\n  const cipher = createCipheriv('aes-128-cbc', encKey, iv)\n  let cipherText = cipher.update(plaintextNormalized).toString('hex')\n  cipherText += cipher.final('hex')\n\n  const hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')])\n\n  const hmac = createHmac('sha256', macKey)\n  hmac.update(hmacPayload)\n  const hmacDigest = hmac.digest()\n\n  return Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')])\n}\n\nexport async function encryptMain(mnemonic: string, password: string) {\n  // logger.debug(\"Encrypting from worker\", mnemonic, password);\n  const encryptedBuffer = await encryptMnemonic(mnemonic, password)\n  return encryptedBuffer.toString('hex')\n}\n\nexport async function encrypt(plaintextBuffer: Buffer, password: string) {\n  const mnemonic = plaintextBuffer.toString()\n  const encryptedMnemonicHex = await encryptMain(mnemonic, password)\n  return encryptedMnemonicHex\n  // const encryptedBuffer = await encryptMnemonic(mnemonic, password);\n  // return encryptedBuffer.toString(\"hex\");\n}\n","import { fromBase58 } from 'bip32'\nimport { getPublicKeyFromPrivate, makeAuthResponse } from 'blockstack'\n\nimport { IdentityKeyPair } from './utils/index'\nimport { getHubPrefix, makeGaiaAssociationToken } from './utils/gaia'\nimport AppsNode from './nodes/apps-node'\n\nexport default class Identity {\n  public keyPair: IdentityKeyPair\n  public address: string\n\n  constructor({ keyPair, address }: { keyPair: IdentityKeyPair; address: string; }) {\n    this.keyPair = keyPair\n    this.address = address\n  }\n\n  async makeAuthResponse({ appDomain, gaiaUrl, transitPublicKey, profile }: { \n    appDomain: string\n    gaiaUrl: string\n    transitPublicKey: string\n    profile?: {}\n  }) {\n    const appPrivateKey = this.appPrivateKey(appDomain)\n    const hubPrefix = await getHubPrefix(gaiaUrl)\n    const profileUrl = await this.profileUrl(hubPrefix)\n    // const appBucketUrl = await getAppBucketUrl(gaiaUrl, appPrivateKey)\n\n    const compressedAppPublicKey = getPublicKeyFromPrivate(appPrivateKey.slice(0, 64))\n    const associationToken = makeGaiaAssociationToken(this.keyPair.key, compressedAppPublicKey)\n\n    return makeAuthResponse(\n      this.keyPair.key,\n      profile || {},\n      '',\n      {\n        profileUrl\n      },\n      undefined,\n      appPrivateKey,\n      undefined,\n      transitPublicKey,\n      gaiaUrl,\n      undefined,\n      associationToken\n    )\n  }\n\n  appPrivateKey(appDomain: string) {\n    const { salt, appsNodeKey } = this.keyPair\n    const appsNode = new AppsNode(fromBase58(appsNodeKey), salt)\n    const appPrivateKey = appsNode.getAppNode(appDomain).getAppPrivateKey()\n    return appPrivateKey\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async profileUrl(gaiaUrl: string) {\n    // future proofing for code that may require network requests to find profile\n    return `${gaiaUrl}${this.address}/profile.json`\n  }\n}\n","import { randomBytes } from 'crypto-browserify'\nimport { TokenSigner } from 'jsontokens'\nimport { getPublicKeyFromPrivate } from 'blockstack'\n\nexport const getHubInfo = async (hubUrl: string) => {\n  const response = await fetch(`${hubUrl}/hub_info`)\n  const data = await response.json()\n  return data\n}\n\nexport const getHubPrefix = async (hubUrl: string) => {\n  const { read_url_prefix } = await getHubInfo(hubUrl)\n  return read_url_prefix\n}\n\nexport const makeGaiaAssociationToken = (secretKeyHex: string, childPublicKeyHex: string ) => {\n  const LIFETIME_SECONDS = 365 * 24 * 3600\n  const signerKeyHex = secretKeyHex.slice(0, 64)\n  const compressedPublicKeyHex = getPublicKeyFromPrivate(signerKeyHex)\n  const salt = randomBytes(16).toString('hex')\n  const payload = {\n    childToAssociate: childPublicKeyHex,\n    iss: compressedPublicKeyHex,\n    exp: LIFETIME_SECONDS + (new Date().getTime() / 1000),\n    iat: Date.now() / 1000,\n    salt\n  }\n\n  const token = new TokenSigner('ES256K', signerKeyHex).sign(payload)\n  return token\n}\n","import Wallet from './wallet'\n\nexport default {\n  Wallet\n}\n","import { generateMnemonic, mnemonicToSeed, validateMnemonic } from 'bip39'\nimport { fromSeed, BIP32Interface } from 'bip32'\nimport { randomBytes } from 'crypto-browserify'\n\nimport { getBlockchainIdentities, IdentityKeyPair } from './utils'\nimport { encrypt } from './encryption/encrypt'\nimport Identity from './identity'\n\nexport interface ConstructorOptions {\n  identityPublicKeychain: string\n  bitcoinPublicKeychain: string\n  firstBitcoinAddress: string\n  identityKeypairs: IdentityKeyPair[]\n  identityAddresses: string[]\n  encryptedBackupPhrase: string\n}\n\nexport default class Wallet {\n  encryptedBackupPhrase: string\n  bitcoinPublicKeychain: string\n  firstBitcoinAddress: string\n  identityKeypairs: IdentityKeyPair[]\n  identityAddresses: string[]\n  identityPublicKeychain: string\n  identities: Identity[]\n\n  constructor({\n    encryptedBackupPhrase,\n    identityPublicKeychain,\n    bitcoinPublicKeychain,\n    firstBitcoinAddress,\n    identityKeypairs,\n    identityAddresses\n  }: ConstructorOptions) {\n    this.encryptedBackupPhrase = encryptedBackupPhrase\n    this.identityPublicKeychain = identityPublicKeychain\n    this.bitcoinPublicKeychain = bitcoinPublicKeychain\n    this.firstBitcoinAddress = firstBitcoinAddress\n    this.identityKeypairs = identityKeypairs\n    this.identityAddresses = identityAddresses\n    const identities: Identity[] = []\n    identityKeypairs.forEach((keyPair, index) => {\n      const address = identityAddresses[index]\n      const identity = new Identity({ keyPair, address })\n      identities.push(identity)\n    })\n    this.identities = identities\n  }\n\n  static async generate(password: string) {\n    const STRENGTH = 128 // 128 bits generates a 12 word mnemonic\n    const backupPhrase = generateMnemonic(STRENGTH, randomBytes)\n    const seedBuffer = await mnemonicToSeed(backupPhrase)\n    const masterKeychain = fromSeed(seedBuffer)\n    const ciphertextBuffer = await encrypt(Buffer.from(backupPhrase), password)\n    const encryptedBackupPhrase = ciphertextBuffer.toString()\n    return this.createAccount(encryptedBackupPhrase, masterKeychain)\n  }\n\n  static async restore(password: string, backupPhrase: string) {\n    if (!validateMnemonic(backupPhrase)) {\n      throw new Error('Invalid mnemonic used to restore wallet')\n    }\n    const seedBuffer = await mnemonicToSeed(backupPhrase)\n    const masterKeychain = fromSeed(seedBuffer)\n    const ciphertextBuffer = await encrypt(Buffer.from(backupPhrase), password)\n    const encryptedBackupPhrase = ciphertextBuffer.toString()\n    return this.createAccount(encryptedBackupPhrase, masterKeychain)\n  }\n\n  static createAccount(encryptedBackupPhrase: string, masterKeychain: BIP32Interface, identitiesToGenerate = 1) {\n    const walletAttrs = getBlockchainIdentities(masterKeychain, identitiesToGenerate)\n    return new this({\n      ...walletAttrs,\n      encryptedBackupPhrase\n    })\n  }\n}\n"],"names":["AppNode","hdNode","appDomain","getAppPrivateKey","this","privateKey","Error","toString","getAddress","AppsNode","appsHdNode","salt","getNode","getAppNode","appIndex","string","hash","length","i","charCodeAt","hashCode","createHash","update","digest","appNode","deriveHardened","toBase58","getSalt","IdentityAddressOwnerNode","ownerHdNode","getIdentityKey","getIdentityKeyID","publicKey","getAppsNode","getEncryptionNode","getSigningNode","getIdentityOwnerAddressNode","identityPrivateKeychain","identityIndex","isNeutered","publicKeyHex","node","address","toBase58Check","crypto","hash160","networks","bitcoin","pubKeyHash","encrypt","plaintextBuffer","password","mnemonic","encryptMain","encryptMnemonic","encryptedBuffer","validateMnemonic","normalizeMnemonic","normalizedMnemonic","plaintextNormalized","Buffer","from","randomBytes","keysAndIV","pbkdf2Sync","encKey","slice","macKey","iv","cipher","createCipheriv","cipherText","hmacPayload","concat","hmac","createHmac","hmacDigest","mnemonicToEntropy","Identity","keyPair","makeAuthResponse","gaiaUrl","transitPublicKey","profile","appPrivateKey","_this2","hubUrl","fetch","response","json","getHubInfo","read_url_prefix","getHubPrefix","hubPrefix","profileUrl","childPublicKeyHex","signerKeyHex","compressedPublicKeyHex","payload","associationToken","getPublicKeyFromPrivate","key","childToAssociate","iss","exp","Date","getTime","iat","now","TokenSigner","sign","undefined","fromBase58","appsNodeKey","Wallet","identityPublicKeychain","bitcoinPublicKeychain","firstBitcoinAddress","identityKeypairs","identityAddresses","encryptedBackupPhrase","identities","forEach","index","identity","push","generate","backupPhrase","generateMnemonic","mnemonicToSeed","seedBuffer","masterKeychain","fromSeed","ciphertextBuffer","createAccount","restore","_this4","identitiesToGenerate","identityPrivateKeychainNode","getIdentityPrivateKeychain","bitcoinPrivateKeychainNode","getBitcoinPrivateKeychain","neutered","bitcoinPublicKeychainNode","bitcoinKeychain","addressIndex","chainType","chain","derive","getBitcoinAddressNode","identityKeyPair","appsNode","identityOwnerAddressNode","keyID","getBlockchainIdentities"],"mappings":"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"}